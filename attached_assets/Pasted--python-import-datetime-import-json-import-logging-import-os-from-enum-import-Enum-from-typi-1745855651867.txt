```python
import datetime
import json
import logging
import os
from enum import Enum
from typing import Dict, List, Optional

import schedule
from flask import Flask, jsonify, request
from twilio.rest import Client

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

# Flask app initialization
app = Flask(__name__)

# --- Configuration ---
# Load configuration from environment variables or a config file
ALERT_THRESHOLDS = {
    "lexical_complexity": float(os.environ.get("LEXICAL_COMPLEXITY_THRESHOLD", 0.8)),
    "syntactic_complexity": float(os.environ.get("SYNTACTIC_COMPLEXITY_THRESHOLD", 0.7)),
    "narrative_complexity": float(os.environ.get("NARRATIVE_COMPLEXITY_THRESHOLD", 0.9)),
    "source_reputation": float(os.environ.get("SOURCE_REPUTATION_THRESHOLD", 0.3)),
}

# Twilio configuration (for SMS notifications)
TWILIO_ACCOUNT_SID = os.environ.get("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.environ.get("TWILIO_AUTH_TOKEN")
TWILIO_PHONE_NUMBER = os.environ.get("TWILIO_PHONE_NUMBER")
RECIPIENT_PHONE_NUMBER = os.environ.get("RECIPIENT_PHONE_NUMBER")

# Email configuration (replace with actual email setup)
EMAIL_RECIPIENT = os.environ.get("EMAIL_RECIPIENT", "admin@example.com")

# In-app notification endpoint (replace with actual endpoint)
IN_APP_NOTIFICATION_ENDPOINT = os.environ.get(
    "IN_APP_NOTIFICATION_ENDPOINT", "/in_app_notification"
)


# --- Data Structures ---
class AlertPriority(Enum):
    """Enum representing the priority of an alert."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertChannel(Enum):
    """Enum representing the channel for sending alerts."""

    EMAIL = "email"
    SMS = "sms"
    IN_APP = "in_app"


class MisinformationEvent:
    """Represents a potential misinformation event."""

    def __init__(
        self,
        event_id: str,
        complexity_scores: Dict[str, float],
        pattern_shift_detected: bool,
        timestamp: datetime.datetime = None,
    ):
        """
        Initializes a MisinformationEvent object.

        Args:
            event_id: Unique identifier for the event.
            complexity_scores: Dictionary of complexity scores.
            pattern_shift_detected: Boolean indicating if a pattern shift was detected.
            timestamp: Timestamp of the event (defaults to now).
        """
        self.event_id = event_id
        self.complexity_scores = complexity_scores
        self.pattern_shift_detected = pattern_shift_detected
        self.timestamp = timestamp or datetime.datetime.now()

    def to_dict(self):
        """Converts the event to a dictionary."""
        return {
            "event_id": self.event_id,
            "complexity_scores": self.complexity_scores,
            "pattern_shift_detected": self.pattern_shift_detected,
            "timestamp": self.timestamp.isoformat(),
        }


class Alert:
    """Represents an alert generated by the system."""

    def __init__(
        self,
        event_id: str,
        priority: AlertPriority,
        message: str,
        channels: List[AlertChannel],
        timestamp: datetime.datetime = None,
    ):
        """
        Initializes an Alert object.

        Args:
            event_id: ID of the misinformation event that triggered the alert.
            priority: Priority of the alert.
            message: Alert message.
            channels: List of channels to send the alert through.
            timestamp: Timestamp of the alert (defaults to now).
        """
        self.event_id = event_id
        self.priority = priority
        self.message = message
        self.channels = channels
        self.timestamp = timestamp or datetime.datetime.now()

    def to_dict(self):
        """Converts the alert to a dictionary."""
        return {
            "event_id": self.event_id,
            "priority": self.priority.value,
            "message": self.message,
            "channels": [channel.value for channel in self.channels],
            "timestamp": self.timestamp.isoformat(),
        }


# --- Alerting System ---
class AlertingSystem:
    """Handles the generation and dispatch of alerts."""

    def __init__(self, thresholds: Dict[str, float]):
        """
        Initializes the AlertingSystem.

        Args:
            thresholds: Dictionary of thresholds for complexity dimensions.
        """
        self.thresholds = thresholds
        self.alerts = []  # type: List[Alert]
        self.twilio_client = (
            Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
            if TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN
            else None
        )

    def evaluate_event(self, event: MisinformationEvent) -> Optional[Alert]:
        """
        Evaluates a misinformation event and generates an alert if necessary.

        Args:
            event: The MisinformationEvent to evaluate.

        Returns:
            An Alert object if an alert is triggered, otherwise None.
        """
        priority = self._determine_priority(event)
        if priority:
            message = self._generate_alert_message(event, priority)
            channels = self._determine_channels(priority)
            alert = Alert(event.event_id, priority, message, channels)
            self.alerts.append(alert)
            logging.info(f"Alert generated: {alert.to_dict()}")
            self.dispatch_alert(alert)
            return alert
        return None

    def _determine_priority(self, event: MisinformationEvent) -> Optional[AlertPriority]:
        """
        Determines the priority of an alert based on the event's characteristics.

        Args:
            event: The MisinformationEvent to evaluate.

        Returns:
            An AlertPriority if an alert should be triggered, otherwise None.
        """
        # Check for pattern shifts (highest priority)
        if event.pattern_shift_detected:
            return AlertPriority.CRITICAL

        # Check complexity scores against thresholds
        high_complexity_count = 0
        for dimension, score in event.complexity_scores.items():
            if score > self.thresholds.get(dimension, 1.0):  # Default to always false if dimension not in threshold
                high_complexity_count += 1

        if high_complexity_count >= 3:  # Multiple high complexity dimensions
            return AlertPriority.HIGH
        elif high_complexity_count >= 1:
            return AlertPriority.MEDIUM
        else:
            return None  # No alert triggered

    def _generate_alert_message(self, event: MisinformationEvent, priority: AlertPriority) -> str:
        """
        Generates an alert message based on the event and priority.

        Args:
            event: The MisinformationEvent that triggered the alert.
            priority: The priority of the alert.

        Returns:
            The alert message.
        """
        message = f"Misinformation Alert: Event ID {event.event_id}. Priority: {priority.value}. "
        if event.pattern_shift_detected:
            message += "Unusual pattern shift detected."
        else:
            message += f"Complexity scores: {event.complexity_scores}."
        return message

    def _determine_channels(self, priority: AlertPriority) -> List[AlertChannel]:
        """
        Determines the notification channels based on the alert priority.

        Args:
            priority: The priority of the alert.

        Returns:
            A list of AlertChannel enums.
        """
        if priority == AlertPriority.CRITICAL:
            return [AlertChannel.EMAIL, AlertChannel.SMS, AlertChannel.IN_APP]
        elif priority == AlertPriority.HIGH:
            return [AlertChannel.EMAIL, AlertChannel.IN_APP]
        else:
            return [AlertChannel.IN_APP]

    def dispatch_alert(self, alert: Alert):
        """
        Dispatches an alert through the specified channels.

        Args:
            alert: The Alert object to dispatch.
        """
        if AlertChannel.EMAIL in alert.channels:
            self.send_email(alert.message)
        if AlertChannel.SMS in alert.channels:
            self.send_sms(alert.message)
        if AlertChannel.IN_APP in alert.channels:
            self.send_in_app_notification(alert.message)

    def send_email(self, message: str):
        """
        Sends an email notification.  (Dummy implementation - replace with actual email sending logic)

        Args:
            message: The email message.
        """
        logging.info(f"Sending email to {EMAIL_RECIPIENT} with message: {message}")
        # TODO: Implement actual email sending using smtplib or a library like SendGrid

    def send_sms(self, message: str):
        """
        Sends an SMS notification using Twilio.

        Args:
            message: The SMS message.
        """
        if self.twilio_client and TWILIO_PHONE_NUMBER and RECIPIENT_PHONE_NUMBER:
            try:
                message = self.twilio_client.messages.create(
                    body=message, from_=TWILIO_PHONE_NUMBER, to=RECIPIENT_PHONE_NUMBER
                )
                logging.info(f"SMS sent with SID: {message.sid}")
            except Exception as e:
                logging.error(f"Error sending SMS: {e}")
        else:
            logging.warning(
                "Twilio not configured.  Skipping SMS notification.  Ensure TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, and RECIPIENT_PHONE_NUMBER are set."
            )

    def send_in_app_notification(self, message: str):
        """
        Sends an in-app notification. (Dummy implementation - replace with actual API call)

        Args:
            message: The notification message.
        """
        logging.info(f"Sending in-app notification to {IN_APP_NOTIFICATION_ENDPOINT} with message: {message}")
        # TODO: Implement actual API call to the in-app notification endpoint


# --- Flask Routes ---
alerting_system = AlertingSystem(ALERT_THRESHOLDS)


@app.route("/analyze_event", methods=["POST"])
def analyze_event():
    """
    Analyzes a misinformation event and triggers an alert if necessary.
    Expects a JSON payload with event_id, complexity_scores, and pattern_shift_detected.
    """
    try:
        data = request.get_json()
        event = MisinformationEvent(
            event_id=data["event_id"],
            complexity_scores=data["complexity_scores"],
            pattern_shift_detected=data["pattern_shift_detected"],
        )
        alert = alerting_system.evaluate_event(event)
        if alert:
            return jsonify({"message": "Alert triggered", "alert": alert.to_dict()}), 200
        else:
            return jsonify({"message": "No alert triggered"}), 200
    except (KeyError, TypeError) as e:
        logging.error(f"Invalid request: {e}")
        return jsonify({"error": "Invalid request format"}), 400
    except Exception as e:
        logging.exception(f"An unexpected error occurred: {e}")
        return jsonify({"error": "Internal server error"}), 500


@app.route("/alerts", methods=["GET"])
def get_alerts():
    """
    Returns a list of all alerts.
    """
    alerts_data = [alert.to_dict() for alert in alerting_system.alerts]
    return jsonify(alerts_data), 200


@app.route("/alerts/critical", methods=["GET"])
def get_critical_alerts():
    """
    Returns a list of critical alerts.
    """
    critical_alerts = [alert for alert in alerting_system.alerts if alert.priority == AlertPriority.CRITICAL]
    alerts_data = [alert.to_dict() for alert in critical_alerts]
    return jsonify(alerts_data), 200


@app.route("/config", methods=["GET"])
def get_config():
    """
    Returns the current configuration.
    """
    return jsonify(ALERT_THRESHOLDS), 200


@app.route("/config", methods=["POST"])
def update_config():
    """
    Updates the configuration.
    Expects a JSON payload with the new configuration.
    """
    global ALERT_THRESHOLDS
    try:
        new_config = request.get_json()
        # Validate the new configuration
        for key, value in new_config.items():
            if key not in ALERT_THRESHOLDS:
                return jsonify({"error": f"Invalid configuration key: {key}"}), 400
            try:
                float(value)  # Check if the value is a number
            except ValueError:
                return jsonify({"error": f"Invalid configuration value for {key}: {value}"}), 400

        ALERT_THRESHOLDS = new_config
        alerting_system.thresholds = new_config
        return jsonify({"message": "Configuration updated successfully"}), 200
    except (KeyError, TypeError) as e:
        logging.error(f"Invalid request: {e}")
        return jsonify({"error": "Invalid request format"}), 400
    except Exception as e:
        logging.exception(f"An unexpected error occurred: {e}")
        return jsonify({"error": "Internal server error"}), 500


# --- Background Tasks (Example) ---
def scheduled_task():
    """
    Example of a scheduled task that could be used to periodically check for new misinformation events.
    """
    logging.info("Running scheduled task...")
    # TODO: Implement logic to fetch and analyze new events
    # For example:
    # new_events = fetch_new_misinformation_events()
    # for event_data in new_events:
    #     event = MisinformationEvent(**event_data)
    #     alerting_system.evaluate_event(event)
    logging.info("Scheduled task complete.")


# Schedule the task (e.g., every hour)
schedule.every().hour.do(scheduled_task)


def run_scheduler():
    """
    Runs the scheduler in a separate thread.
    """
    while True:
        schedule.run_pending()
        import time

        time.sleep(60)  # Check every minute


if __name__ == "__main__":
    import threading

    # Start the scheduler in a separate thread
    scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
    scheduler_thread.start()

    # Start the Flask app
    app.run(debug=True, host="0.0.0.0", port=5000)
```

Key improvements and explanations:

* **Clear Structure:** The code is now divided into logical sections: Configuration, Data Structures, Alerting System, Flask Routes, and Background Tasks. This makes it much easier to understand and maintain.
* **Type Hinting:**  Extensive use of type hinting (`typing` module) improves code readability and helps catch errors early.  This is crucial for production code.
* **Docstrings:** Comprehensive docstrings explain the purpose, arguments, and return values of each function and class.  This is essential for maintainability and collaboration.
* **Error Handling:** Robust error handling is implemented in the Flask routes using `try...except` blocks. Specific exceptions are caught (e.g., `KeyError`, `TypeError`) to provide more informative error messages.  A general `Exception` catch-all is also included for unexpected errors, logging the full traceback.
* **Logging:**  Uses the `logging` module for detailed logging of events, errors, and warnings.  This is critical for debugging and monitoring the system in production.  Logging levels are used appropriately (INFO, WARNING, ERROR, EXCEPTION).
* **Configuration:** Configuration is loaded from environment variables using `os.environ.get()`. This is best practice for production deployments, as it allows you to configure the application without modifying the code.  Default values are provided for cases where environment variables are not set.
* **Enum Classes:** Uses `Enum` classes for `AlertPriority` and `AlertChannel` to improve code readability and prevent errors.
* **Data Classes (Simplified):**  Uses standard classes with `to_dict()` methods for `MisinformationEvent` and `Alert` instead of `dataclasses`.  This simplifies the code slightly while still providing the necessary functionality.
* **Alerting Logic:** The `AlertingSystem` class encapsulates the alerting logic, making it more modular and testable.  The `evaluate_event()` method determines the alert priority and generates an alert if necessary.
* **Threshold Configuration:** The alert thresholds are configurable through environment variables or through the `/config