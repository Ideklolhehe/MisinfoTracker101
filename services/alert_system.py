"""
Misinformation Alert System service for the CIVILIAN platform.
Monitors complexity metrics and triggers alerts based on configured thresholds.
"""

import json
import logging
import os
from enum import Enum
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple

from app import db
from models import DetectedNarrative, SystemLog, User
from services.time_series_analyzer import TimeSeriesAnalyzer

logger = logging.getLogger(__name__)

class AlertPriority(Enum):
    """Enum representing the priority of an alert."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class AlertChannel(Enum):
    """Enum representing the channel for sending alerts."""
    EMAIL = "email"
    SMS = "sms"
    IN_APP = "in_app"

class MisinformationEvent:
    """Represents a potential misinformation event."""
    
    def __init__(
        self,
        event_id: str,
        complexity_scores: Dict[str, float],
        pattern_shift_detected: bool,
        timestamp: datetime = None,
    ):
        """
        Initializes a MisinformationEvent object.
        
        Args:
            event_id: Unique identifier for the event.
            complexity_scores: Dictionary of complexity scores.
            pattern_shift_detected: Boolean indicating if a pattern shift was detected.
            timestamp: Timestamp of the event (defaults to now).
        """
        self.event_id = event_id
        self.complexity_scores = complexity_scores
        self.pattern_shift_detected = pattern_shift_detected
        self.timestamp = timestamp or datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """Converts the event to a dictionary."""
        return {
            "event_id": self.event_id,
            "complexity_scores": self.complexity_scores,
            "pattern_shift_detected": self.pattern_shift_detected,
            "timestamp": self.timestamp.isoformat(),
        }

class Alert:
    """Represents an alert generated by the system."""
    
    def __init__(
        self,
        event_id: str,
        priority: AlertPriority,
        message: str,
        channels: List[AlertChannel],
        timestamp: datetime = None,
    ):
        """
        Initializes an Alert object.
        
        Args:
            event_id: ID of the misinformation event that triggered the alert.
            priority: Priority of the alert.
            message: Alert message.
            channels: List of channels to send the alert through.
            timestamp: Timestamp of the alert (defaults to now).
        """
        self.event_id = event_id
        self.priority = priority
        self.message = message
        self.channels = channels
        self.timestamp = timestamp or datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """Converts the alert to a dictionary."""
        return {
            "event_id": self.event_id,
            "priority": self.priority.value,
            "message": self.message,
            "channels": [channel.value for channel in self.channels],
            "timestamp": self.timestamp.isoformat(),
        }

class AlertSystem:
    """Handles the generation and dispatch of alerts based on complexity metrics."""
    
    # Default thresholds for alert triggers
    DEFAULT_THRESHOLDS = {
        "lexical_complexity": 0.8,
        "syntactic_complexity": 0.7,
        "narrative_complexity": 0.9,
        "source_reputation": 0.3,
        "overall_complexity": 0.85,
        "linguistic_complexity": 0.8,
        "logical_structure": 0.7,
        "rhetorical_techniques": 0.8,
        "emotional_manipulation": 0.9,
    }
    
    def __init__(self, thresholds: Optional[Dict[str, float]] = None):
        """
        Initializes the AlertSystem.
        
        Args:
            thresholds: Dictionary of thresholds for complexity dimensions.
        """
        self.thresholds = thresholds or self._load_thresholds_from_env()
        self.alerts = []  # Store recent alerts in memory
        
        # Initialize notification service configurations
        self._init_notification_services()
    
    def _load_thresholds_from_env(self) -> Dict[str, float]:
        """
        Load alert thresholds from environment variables.
        
        Returns:
            Dictionary of thresholds.
        """
        thresholds = self.DEFAULT_THRESHOLDS.copy()
        
        # Override with environment values if present
        for key in thresholds:
            env_key = f"{key.upper()}_THRESHOLD"
            if env_key in os.environ:
                try:
                    thresholds[key] = float(os.environ[env_key])
                except (ValueError, TypeError):
                    logger.warning(f"Invalid threshold value for {env_key} in environment variables")
        
        return thresholds
    
    def _init_notification_services(self):
        """Initialize notification service configurations."""
        # Email configuration
        self.email_recipient = os.environ.get("EMAIL_RECIPIENT", "admin@example.com")
        
        # SMS configuration (via Twilio)
        self.twilio_enabled = all([
            os.environ.get("TWILIO_ACCOUNT_SID"),
            os.environ.get("TWILIO_AUTH_TOKEN"),
            os.environ.get("TWILIO_PHONE_NUMBER"),
            os.environ.get("RECIPIENT_PHONE_NUMBER")
        ])
        
        if not self.twilio_enabled:
            logger.warning("Twilio SMS alerts disabled due to missing configuration")
    
    def evaluate_narrative(self, narrative_id: int) -> Optional[Alert]:
        """
        Evaluates a narrative for potential alerts based on complexity metrics.
        
        Args:
            narrative_id: The narrative ID to evaluate.
            
        Returns:
            An Alert object if an alert is triggered, otherwise None.
        """
        try:
            # Get the narrative
            narrative = DetectedNarrative.query.get(narrative_id)
            if not narrative:
                logger.warning(f"Narrative {narrative_id} not found")
                return None
            
            # Get complexity data
            complexity_data = self._get_narrative_complexity(narrative)
            if not complexity_data:
                logger.warning(f"No complexity data available for narrative {narrative_id}")
                return None
            
            # Check for pattern shift using time series analysis
            pattern_shift = self._detect_pattern_shift(narrative_id)
            
            # Create event object
            event = MisinformationEvent(
                event_id=str(narrative_id),
                complexity_scores=complexity_data,
                pattern_shift_detected=pattern_shift,
                timestamp=datetime.now()
            )
            
            # Evaluate the event
            return self.evaluate_event(event)
            
        except Exception as e:
            logger.error(f"Error evaluating narrative for alerts: {e}")
            return None
    
    def evaluate_event(self, event: MisinformationEvent) -> Optional[Alert]:
        """
        Evaluates a misinformation event and generates an alert if necessary.
        
        Args:
            event: The MisinformationEvent to evaluate.
            
        Returns:
            An Alert object if an alert is triggered, otherwise None.
        """
        try:
            # Determine alert priority
            priority = self._determine_priority(event)
            
            if priority:
                # Generate alert message
                message = self._generate_alert_message(event, priority)
                
                # Determine notification channels
                channels = self._determine_channels(priority)
                
                # Create the alert
                alert = Alert(event.event_id, priority, message, channels)
                
                # Store alert
                self.alerts.append(alert)
                
                # Log the alert
                self._log_alert(alert)
                
                # Dispatch the alert through appropriate channels
                self.dispatch_alert(alert)
                
                return alert
            
            return None
            
        except Exception as e:
            logger.error(f"Error evaluating event {event.event_id}: {e}")
            return None
    
    def _determine_priority(self, event: MisinformationEvent) -> Optional[AlertPriority]:
        """
        Determines the priority of an alert based on the event's characteristics.
        
        Args:
            event: The MisinformationEvent to evaluate.
            
        Returns:
            An AlertPriority if an alert should be triggered, otherwise None.
        """
        # Check for pattern shifts (highest priority)
        if event.pattern_shift_detected:
            return AlertPriority.CRITICAL
        
        # Check complexity scores against thresholds
        high_complexity_count = 0
        for dimension, score in event.complexity_scores.items():
            threshold = self.thresholds.get(dimension, 1.0)  # Default to always false if dimension not in threshold
            if score > threshold:
                high_complexity_count += 1
        
        # Determine priority based on number of exceeded thresholds
        if high_complexity_count >= 3:
            return AlertPriority.HIGH
        elif high_complexity_count >= 2:
            return AlertPriority.MEDIUM
        elif high_complexity_count >= 1:
            return AlertPriority.LOW
        
        return None  # No alert triggered
    
    def _generate_alert_message(self, event: MisinformationEvent, priority: AlertPriority) -> str:
        """
        Generates an alert message based on the event and priority.
        
        Args:
            event: The MisinformationEvent that triggered the alert.
            priority: The priority of the alert.
            
        Returns:
            The alert message.
        """
        # Get narrative title if available
        narrative_title = None
        try:
            narrative = DetectedNarrative.query.get(int(event.event_id))
            if narrative:
                narrative_title = narrative.title
        except:
            pass
        
        # Construct message
        title_str = f" '{narrative_title}'" if narrative_title else ""
        
        message = f"Misinformation Alert: Narrative {event.event_id}{title_str}. Priority: {priority.value.upper()}. "
        
        if event.pattern_shift_detected:
            message += "Unusual pattern shift detected in complexity evolution. "
        
        # Add information about exceeded thresholds
        exceeded_dimensions = []
        for dimension, score in event.complexity_scores.items():
            threshold = self.thresholds.get(dimension, 1.0)
            if score > threshold:
                exceeded_dimensions.append(f"{dimension.replace('_', ' ')} ({score:.2f}/{threshold:.2f})")
        
        if exceeded_dimensions:
            message += f"Exceeded thresholds: {', '.join(exceeded_dimensions)}."
        
        return message
    
    def _determine_channels(self, priority: AlertPriority) -> List[AlertChannel]:
        """
        Determines the notification channels based on the alert priority.
        
        Args:
            priority: The priority of the alert.
            
        Returns:
            A list of AlertChannel enums.
        """
        if priority == AlertPriority.CRITICAL:
            return [AlertChannel.EMAIL, AlertChannel.SMS, AlertChannel.IN_APP]
        elif priority == AlertPriority.HIGH:
            return [AlertChannel.EMAIL, AlertChannel.IN_APP]
        else:
            return [AlertChannel.IN_APP]
    
    def dispatch_alert(self, alert: Alert):
        """
        Dispatches an alert through the specified channels.
        
        Args:
            alert: The Alert object to dispatch.
        """
        for channel in alert.channels:
            if channel == AlertChannel.EMAIL:
                self._send_email_alert(alert)
            elif channel == AlertChannel.SMS:
                self._send_sms_alert(alert)
            elif channel == AlertChannel.IN_APP:
                self._send_in_app_alert(alert)
    
    def _send_email_alert(self, alert: Alert):
        """
        Sends an email notification for an alert.
        
        Args:
            alert: The Alert object.
        """
        try:
            # Note: Actual email sending implementation would depend on your email service
            # This is a placeholder that logs the action
            
            logger.info(f"Email alert would be sent to {self.email_recipient}: {alert.message}")
            
            # Record the notification attempt
            self._log_notification_attempt("email", alert)
            
        except Exception as e:
            logger.error(f"Error sending email alert: {e}")
    
    def _send_sms_alert(self, alert: Alert):
        """
        Sends an SMS notification for an alert.
        
        Args:
            alert: The Alert object.
        """
        try:
            if not self.twilio_enabled:
                logger.warning("SMS alert requested but Twilio is not configured")
                return
            
            # Import here to avoid circular imports
            from utils.sms_service import sms_service
            
            # Prepare a more concise message for SMS
            message = f"CIVILIAN ALERT [{alert.priority.value.upper()}]: {alert.message}"
            
            # Send the SMS
            success = sms_service.send_message(message)
            
            if success:
                logger.info(f"SMS alert sent successfully: {alert.message}")
            else:
                logger.warning(f"Failed to send SMS alert: {alert.message}")
            
            # Record the notification attempt
            self._log_notification_attempt("sms", alert)
            
        except Exception as e:
            logger.error(f"Error sending SMS alert: {e}")
    
    def _send_in_app_alert(self, alert: Alert):
        """
        Sends an in-app notification for an alert.
        
        Args:
            alert: The Alert object.
        """
        try:
            # Store alert in the database for in-app notification
            # Note: Actual implementation would depend on your notification system
            
            # This is a placeholder that logs the action
            logger.info(f"In-app alert stored: {alert.message}")
            
            # Record the notification attempt
            self._log_notification_attempt("in_app", alert)
            
        except Exception as e:
            logger.error(f"Error sending in-app alert: {e}")
    
    def _log_notification_attempt(self, channel: str, alert: Alert):
        """
        Log a notification attempt to the system logs.
        
        Args:
            channel: The notification channel used.
            alert: The Alert object.
        """
        try:
            # Create a system log entry
            log_entry = SystemLog(
                log_type="notification",
                component="alert_system",
                message=f"{channel.upper()} notification sent for narrative {alert.event_id}",
                meta_data=json.dumps({
                    "alert_id": id(alert),  # Use object id as unique identifier
                    "event_id": alert.event_id,
                    "priority": alert.priority.value,
                    "channel": channel,
                    "timestamp": datetime.now().isoformat()
                })
            )
            
            db.session.add(log_entry)
            db.session.commit()
            
        except Exception as e:
            logger.error(f"Error logging notification attempt: {e}")
            db.session.rollback()
    
    def _log_alert(self, alert: Alert):
        """
        Log an alert to the system logs.
        
        Args:
            alert: The Alert object.
        """
        try:
            # Create a system log entry
            log_entry = SystemLog(
                log_type="alert",
                component="alert_system",
                message=f"Alert generated for narrative {alert.event_id}: {alert.priority.value}",
                meta_data=json.dumps(alert.to_dict())
            )
            
            db.session.add(log_entry)
            db.session.commit()
            
        except Exception as e:
            logger.error(f"Error logging alert: {e}")
            db.session.rollback()
    
    def _get_narrative_complexity(self, narrative: DetectedNarrative) -> Dict[str, float]:
        """
        Extract complexity scores from a narrative.
        
        Args:
            narrative: The DetectedNarrative object.
            
        Returns:
            Dictionary of complexity scores by dimension.
        """
        complexity_scores = {}
        
        if not narrative.meta_data:
            return complexity_scores
        
        try:
            metadata = json.loads(narrative.meta_data)
            complexity_analysis = metadata.get('complexity_analysis', {})
            
            if 'overall_complexity_score' in complexity_analysis:
                complexity_scores['overall_complexity'] = complexity_analysis['overall_complexity_score']
            
            # Extract dimension scores
            dimensions = [
                ('linguistic_complexity', 'linguistic_complexity', 'score'),
                ('logical_structure', 'logical_structure', 'score'),
                ('rhetorical_techniques', 'rhetorical_techniques', 'score'),
                ('emotional_manipulation', 'emotional_manipulation', 'score')
            ]
            
            for score_key, dim_key, sub_key in dimensions:
                if dim_key in complexity_analysis and sub_key in complexity_analysis[dim_key]:
                    complexity_scores[score_key] = complexity_analysis[dim_key][sub_key]
            
            return complexity_scores
            
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.warning(f"Error extracting complexity scores from narrative {narrative.id}: {e}")
            return complexity_scores
    
    def _detect_pattern_shift(self, narrative_id: int) -> bool:
        """
        Detect if a pattern shift has occurred in the narrative's complexity evolution.
        
        Args:
            narrative_id: The narrative ID to check.
            
        Returns:
            True if a pattern shift is detected, False otherwise.
        """
        try:
            # Use time series analyzer to check for pattern shifts
            trend_metrics = TimeSeriesAnalyzer.calculate_trend_metrics(narrative_id)
            
            if "error" in trend_metrics:
                return False
            
            # Look for signs of pattern shifts:
            # 1. High acceleration (change in slope)
            # 2. Recent change rate significantly different from overall trend
            
            overall_trend = trend_metrics.get('overall_trend', {})
            acceleration = overall_trend.get('acceleration', 0)
            slope = overall_trend.get('slope', 0)
            recent_change_rate = overall_trend.get('recent_change_rate', 0)
            
            # Acceleration threshold: significant change in slope
            if abs(acceleration) > 0.1:
                return True
            
            # Recent change rate significantly different from overall trend
            if abs(recent_change_rate - slope) > 0.2:
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error detecting pattern shift for narrative {narrative_id}: {e}")
            return False
    
    def get_recent_alerts(self, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Get recent alerts.
        
        Args:
            limit: Maximum number of alerts to return.
            
        Returns:
            List of alert dictionaries.
        """
        # Return most recent alerts first
        sorted_alerts = sorted(self.alerts, key=lambda a: a.timestamp, reverse=True)
        return [alert.to_dict() for alert in sorted_alerts[:limit]]
    
    def get_critical_alerts(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get critical alerts.
        
        Args:
            limit: Maximum number of alerts to return.
            
        Returns:
            List of critical alert dictionaries.
        """
        # Filter and sort critical alerts
        critical_alerts = [a for a in self.alerts if a.priority == AlertPriority.CRITICAL]
        sorted_alerts = sorted(critical_alerts, key=lambda a: a.timestamp, reverse=True)
        return [alert.to_dict() for alert in sorted_alerts[:limit]]
    
    def get_alert_count_by_priority(self) -> Dict[str, int]:
        """
        Get count of alerts by priority level.
        
        Returns:
            Dictionary with count by priority.
        """
        counts = {priority.value: 0 for priority in AlertPriority}
        
        for alert in self.alerts:
            counts[alert.priority.value] += 1
        
        return counts